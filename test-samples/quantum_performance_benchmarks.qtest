# Quantum Performance Benchmarks
# TrinaryVM Quantum Interface - Performance Analysis
# Run with: ./target/debug/quantum_terminal < quantum_performance_benchmarks.qtest

# Benchmark 1: Gate Operation Performance Scaling
# Test individual gate performance across different qutrit counts

# Single qutrit gate benchmarks
create register single_perf 1
create circuit single_gate_bench 1

add gate single_gate_bench I 0
execute single_gate_bench single_perf

add gate single_gate_bench X 0
execute single_gate_bench single_perf

add gate single_gate_bench Z 0
execute single_gate_bench single_perf

add gate single_gate_bench H 0
execute single_gate_bench single_perf

add gate single_gate_bench U(1.57,0.78,2.34) 0
execute single_gate_bench single_perf

probabilities single_perf

# Two qutrit gate benchmarks
create register dual_perf 2
create circuit dual_gate_bench 2

add gate dual_gate_bench CX 0 1
execute dual_gate_bench dual_perf

add gate dual_gate_bench CZ 0 1
execute dual_gate_bench dual_perf

add gate dual_gate_bench H 0
add gate dual_gate_bench H 1
execute dual_gate_bench dual_perf

probabilities dual_perf

# Multi-qutrit scaling test
create register quad_perf 4
create circuit quad_gate_bench 4

add gate quad_gate_bench H 0
add gate quad_gate_bench H 1
add gate quad_gate_bench H 2
add gate quad_gate_bench H 3
add gate quad_gate_bench CX 0 1
add gate quad_gate_bench CX 1 2
add gate quad_gate_bench CX 2 3
add gate quad_gate_bench CZ 0 2
add gate quad_gate_bench CZ 1 3

execute quad_gate_bench quad_perf
probabilities quad_perf

# Benchmark 2: Algorithm Scaling Analysis
# Test Grover's algorithm performance across database sizes

grover 3 1      # 3^1 = 3 items
grover 9 4      # 3^2 = 9 items  
grover 27 13    # 3^3 = 27 items
grover 81 40    # 3^4 = 81 items
grover 243 121  # 3^5 = 243 items
grover 729 365  # 3^6 = 729 items

# Benchmark 3: Circuit Depth vs Performance
# Test performance degradation with increasing circuit depth

# Shallow circuit (5 gates)
create register shallow_circuit 3
create circuit depth_5 3
add gate depth_5 H 0
add gate depth_5 CX 0 1
add gate depth_5 H 1
add gate depth_5 CZ 1 2
add gate depth_5 H 2

execute depth_5 shallow_circuit
probabilities shallow_circuit

# Medium circuit (15 gates)
create register medium_circuit 3
create circuit depth_15 3
add gate depth_15 H 0
add gate depth_15 H 1
add gate depth_15 H 2
add gate depth_15 CX 0 1
add gate depth_15 CX 1 2
add gate depth_15 CZ 0 2
add gate depth_15 U(0.5,1.0,1.5) 0
add gate depth_15 U(1.0,0.5,2.0) 1
add gate depth_15 U(1.5,2.0,0.5) 2
add gate depth_15 CX 2 0
add gate depth_15 CZ 1 0
add gate depth_15 H 0
add gate depth_15 H 1
add gate depth_15 H 2
add gate depth_15 CX 0 1

execute depth_15 medium_circuit
probabilities medium_circuit

# Deep circuit (30 gates)
create register deep_circuit 3
create circuit depth_30 3

# Layer 1
add gate depth_30 H 0
add gate depth_30 H 1
add gate depth_30 H 2
add gate depth_30 CX 0 1
add gate depth_30 CX 1 2

# Layer 2
add gate depth_30 U(0.1,0.2,0.3) 0
add gate depth_30 U(0.4,0.5,0.6) 1
add gate depth_30 U(0.7,0.8,0.9) 2
add gate depth_30 CZ 0 2
add gate depth_30 CZ 1 0

# Layer 3
add gate depth_30 X 0
add gate depth_30 X 1
add gate depth_30 X 2
add gate depth_30 CX 2 1
add gate depth_30 CX 1 0

# Layer 4
add gate depth_30 U(1.1,1.2,1.3) 0
add gate depth_30 U(1.4,1.5,1.6) 1
add gate depth_30 U(1.7,1.8,1.9) 2
add gate depth_30 CZ 0 1
add gate depth_30 CZ 1 2

# Layer 5
add gate depth_30 Z 0
add gate depth_30 Z 1
add gate depth_30 Z 2
add gate depth_30 CX 0 2
add gate depth_30 CX 1 0

# Layer 6
add gate depth_30 H 0
add gate depth_30 H 1
add gate depth_30 H 2
add gate depth_30 CZ 2 0
add gate depth_30 CZ 0 1

execute depth_30 deep_circuit
probabilities deep_circuit

# Benchmark 4: Memory Usage Scaling
# Test memory efficiency across different register sizes

create register mem_test_1 1
create register mem_test_2 2
create register mem_test_3 3
create register mem_test_4 4
create register mem_test_5 5
create register mem_test_6 6

# Initialize all registers with superposition
create circuit mem_init_1 1
add gate mem_init_1 H 0
execute mem_init_1 mem_test_1

create circuit mem_init_2 2
add gate mem_init_2 H 0
add gate mem_init_2 H 1
execute mem_init_2 mem_test_2

create circuit mem_init_3 3
add gate mem_init_3 H 0
add gate mem_init_3 H 1
add gate mem_init_3 H 2
execute mem_init_3 mem_test_3

create circuit mem_init_4 4
add gate mem_init_4 H 0
add gate mem_init_4 H 1
add gate mem_init_4 H 2
add gate mem_init_4 H 3
execute mem_init_4 mem_test_4

create circuit mem_init_5 5
add gate mem_init_5 H 0
add gate mem_init_5 H 1
add gate mem_init_5 H 2
add gate mem_init_5 H 3
add gate mem_init_5 H 4
execute mem_init_5 mem_test_5

create circuit mem_init_6 6
add gate mem_init_6 H 0
add gate mem_init_6 H 1
add gate mem_init_6 H 2
add gate mem_init_6 H 3
add gate mem_init_6 H 4
add gate mem_init_6 H 5
execute mem_init_6 mem_test_6

status

# Benchmark 5: Quantum Error Correction Overhead
# Test performance impact of error correction

# Standard 3-qutrit operation
create register standard_ops 3
create circuit standard_circuit 3
add gate standard_circuit H 0
add gate standard_circuit CX 0 1
add gate standard_circuit CZ 1 2
execute standard_circuit standard_ops
probabilities standard_ops

# 9-qutrit error corrected operation
create register ecc_ops 9
create circuit ecc_circuit 9

# Logical qutrit encoding
add gate ecc_circuit H 0
add gate ecc_circuit CX 0 3
add gate ecc_circuit CX 0 6

# Logical operations
add gate ecc_circuit CX 1 4
add gate ecc_circuit CX 1 7
add gate ecc_circuit CZ 2 5
add gate ecc_circuit CZ 2 8

# Error detection
add gate ecc_circuit CX 3 6
add gate ecc_circuit CZ 4 7
add gate ecc_circuit CX 5 8

execute ecc_circuit ecc_ops
probabilities ecc_ops

# Benchmark 6: Optimization Effectiveness Test
# Compare performance with different optimization strategies

# Unoptimized repetitive circuit
create register unopt_test 2
create circuit unoptimized 2

# Redundant operations (should be optimized away)
add gate unoptimized H 0
add gate unoptimized H 0    # H^2 = I
add gate unoptimized X 1
add gate unoptimized X 1
add gate unoptimized X 1    # X^3 = I
add gate unoptimized U(0.001,0.001,0.001) 0  # Near-identity
add gate unoptimized I 1    # Explicit identity

execute unoptimized unopt_test
probabilities unopt_test

# Benchmark 7: Concurrent Quantum Operations
# Test system capacity with multiple simultaneous operations

create register concurrent_1 2
create register concurrent_2 2
create register concurrent_3 2

create circuit concurrent_circuit_1 2
add gate concurrent_circuit_1 H 0
add gate concurrent_circuit_1 CX 0 1

create circuit concurrent_circuit_2 2
add gate concurrent_circuit_2 H 1
add gate concurrent_circuit_2 CZ 0 1

create circuit concurrent_circuit_3 2
add gate concurrent_circuit_3 U(1.0,0.5,2.0) 0
add gate concurrent_circuit_3 U(2.0,1.0,0.5) 1

# Execute all concurrently (simulate parallel execution)
execute concurrent_circuit_1 concurrent_1
execute concurrent_circuit_2 concurrent_2
execute concurrent_circuit_3 concurrent_3

probabilities concurrent_1
probabilities concurrent_2
probabilities concurrent_3

# Benchmark 8: Maximum System Stress Test
# Push system to its limits

create register stress_test_1 10    # Maximum qutrit count
create register stress_test_2 10
create circuit stress_circuit 10

# Create maximum complexity circuit
add gate stress_circuit H 0
add gate stress_circuit H 1
add gate stress_circuit H 2
add gate stress_circuit H 3
add gate stress_circuit H 4
add gate stress_circuit H 5
add gate stress_circuit H 6
add gate stress_circuit H 7
add gate stress_circuit H 8
add gate stress_circuit H 9

# Full connectivity
add gate stress_circuit CX 0 1
add gate stress_circuit CX 1 2
add gate stress_circuit CX 2 3
add gate stress_circuit CX 3 4
add gate stress_circuit CX 4 5
add gate stress_circuit CX 5 6
add gate stress_circuit CX 6 7
add gate stress_circuit CX 7 8
add gate stress_circuit CX 8 9
add gate stress_circuit CX 9 0

execute stress_circuit stress_test_1
execute stress_circuit stress_test_2

# Large Grover search
grover 2187 1093    # 3^7 = 2187 items

# Final system status
status
list registers
list circuits

# Performance summary measurements
measure stress_test_1
measure concurrent_1
measure ecc_ops
measure deep_circuit

status

exit 